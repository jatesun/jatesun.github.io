<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码阅读 on jatesun</title>
    <link>http://jatesun.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link>
    <description>Recent content in 源码阅读 on jatesun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Aug 2016 16:26:31 +0200</lastBuildDate>
    <atom:link href="http://jatesun.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>集合源码之hashMap</title>
      <link>http://jatesun.github.io/2016/08/24/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E4%B9%8Bhashmap</link>
      <pubDate>Wed, 24 Aug 2016 16:26:31 +0200</pubDate>
      
      <guid>http://jatesun.github.io/2016/08/24/%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E4%B9%8Bhashmap</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://oajsuo3nv.bkt.clouddn.com/2016-8-21-%E5%A4%A9%E7%A9%BA.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;引子:69821dbc4807e9884618c48763635519&#34;&gt;引子&lt;/h2&gt;

&lt;p&gt;java的集合类使我们经常使用的，而hashmap更是集合中常用的集合类。由于使用的散列，hashmap的crud操作都接近于常数操作时间，本文目的是探究hashmap的底层实现，看java中的散列实现，希望能给想要了解hashmap实现的童鞋一点帮助，需要注意的是hashmap不是线程安全的集合类。 本文分为三部分：第一部分探究hashmap的数据结构、第二部分探究hashmap的重要算法实现、第三部分探究hashmap中值得探讨的地方。文章不会列出详细源码，常规代码概述而过，文章假定读者已经具备散列的相关基础知识，如果你对散列不熟悉或者想重温一下，请参考&lt;a href=&#34;http://jatesun.github.io/2016/08/12/%E6%95%A3%E5%88%97%E8%A1%A8%E9%9D%A2%E9%9D%A2%E8%A7%82/&#34;&gt;散列表面面观&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;hashmap的数据结构:69821dbc4807e9884618c48763635519&#34;&gt;hashMap的数据结构&lt;/h2&gt;

&lt;p&gt;程序是由数据结构和算法构成，弄懂了数据结构和算法，这个程序也就自然明白。而数据结构更是程序的骨架。所以首先，我们看一下hashmap的数据结构示意图，在示意图的基础上进行。&lt;img src=&#34;http://oajsuo3nv.bkt.clouddn.com/2016-08-21-hashmap.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;散列表相关:69821dbc4807e9884618c48763635519&#34;&gt;散列表相关&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt;：即为上图的table，也就是hashmap底层的存储结构。该数字中存放的是hashmap定义的节点类，由于hashmap对冲突采用的拉链法，所以节点类之间形成了链表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点类&lt;/strong&gt;：存储数据的节点类Entry。节点类数据结构为key、value、hash值以及指向下一个节点的next节点（类似链表的节点类）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;装填因子&lt;/strong&gt;：loadFactor。在散列表面面观中提到，采用拉链法解决冲突的散列表的装填因子在0.75到0.80之间。hashmap的默认装填因子为0.75&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;散列函数&lt;/strong&gt;：下文详述。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始容量大小&lt;/strong&gt;：默认为16，也可以通过构造函数传入，但是必须是2的指数，原因下文详述。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;临界容量&lt;/strong&gt;：即为扩容的临界容量，为容量大小与装填因子的乘积。&lt;/p&gt;

&lt;h4 id=&#34;实例变量:69821dbc4807e9884618c48763635519&#34;&gt;实例变量&lt;/h4&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;大小&lt;/strong&gt;：hashmap的大小（size）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;最大容量&lt;/strong&gt;：MAXIMUM_CAPACITY，为1 &amp;lt;&amp;lt; 30。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;修改次数&lt;/strong&gt;：modCount。&lt;/p&gt;

&lt;h2 id=&#34;hashmap关键算法实现:69821dbc4807e9884618c48763635519&#34;&gt;hashMap关键算法实现&lt;/h2&gt;

&lt;p&gt;hashMap实现了map接口，下面我们会对map接口中的关键方法进行分析。&lt;/p&gt;

&lt;h4 id=&#34;构造方法:69821dbc4807e9884618c48763635519&#34;&gt;构造方法&lt;/h4&gt;

&lt;p&gt;hashMap提供了三个构造函数：无参构造函数、单参构造函数（容量）、双参构造函数（容量、装填因子）。我们探讨双参构造函数，其他两个都是以此为基础。构造方法分为如下几步：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;参数校验&lt;/strong&gt;：
1、如果初始容量小于0，抛出参数异常。如果初始容量大于hashmap最大容量，那么默认赋值为最大容量
2、如果装填因子小于0或不合法也抛出参数异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;调整容量&lt;/strong&gt;：调整容量至不小于初始容量的2的指数容量。即容量必须为2的指数大小。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;：初始化装填因子、初始化临界容量、初始化数组（大小即为调整容量后的大小）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;init函数&lt;/strong&gt;：钩子函数，用于子类实现自己特殊要求。&lt;/p&gt;

&lt;h4 id=&#34;重要算法:69821dbc4807e9884618c48763635519&#34;&gt;重要算法&lt;/h4&gt;

&lt;p&gt;对hashmap中重要的算法案进行分析，分为增删改查。所有的增删查方法modcount都要修改。&lt;/p&gt;

&lt;h5 id=&#34;增-put-k-v-改:69821dbc4807e9884618c48763635519&#34;&gt;增（put（K,V））、改&lt;/h5&gt;

&lt;p&gt;put的过程很简单：先校验参数，如果key为null那么就调用putForNullKey方法，否则找到key对应的table位置，遍历该位置的链表，如果链表中有该key那么就修改value否则就新增一个节点到改链表里。我们讨论put方法的几个函数细节：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;putForNullKey&lt;/strong&gt;：此方法针对key为null的put，需要注意的是null总是放在table[0]的位置。方法步骤跟put普通元素一样，遍历table[0]的链表，如果链表中存在null那么就修改value，如果不存在就新增Entry节点。看下面的动图可能更加形象。&lt;img src=&#34;http://oajsuo3nv.bkt.clouddn.com/2016-8-17-put-null.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;hash重散列&lt;/strong&gt;:将key的hashcode再进行一次散列计算，使hash的值更加分散。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;indexFor&lt;/strong&gt;：见最后一部分的问题探讨。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;addEntry&lt;/strong&gt;：增加一个节点。由于hashmap维护的是单链表，所以是在表头插入。增加节点的时候我们要考虑增加后是否需要扩容。如果需要扩容即扩容两倍，然后把源hashmap的table中的值拷贝到新的table中，需要重新散列，所以这个操作为O(n)时间复杂度。&lt;/p&gt;

&lt;h5 id=&#34;删-remove-k:69821dbc4807e9884618c48763635519&#34;&gt;删（remove(K)）&lt;/h5&gt;

&lt;p&gt;删除的过程也很清晰：先计算key所对应的table索引值，然后就是单链表删除节点的方法（单链表删除需要保留前一个节点以便完成节点删除后的替换）。我们以删除10为例子，看下过程。&lt;img src=&#34;http://oajsuo3nv.bkt.clouddn.com/2016-8-24-remove.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;查-get-key:69821dbc4807e9884618c48763635519&#34;&gt;查（get(key)）&lt;/h5&gt;

&lt;p&gt;查询很简单：如果为null就调用getForNullKey（table[0]顺序查找）。不为空找到table索引，然后遍历索引所在的单链表，如果找到key返回对应的value，否则返回null。查询比较简单，这里就不动态展示了。&lt;/p&gt;

&lt;h5 id=&#34;其他方法:69821dbc4807e9884618c48763635519&#34;&gt;其他方法&lt;/h5&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;size&lt;/strong&gt;：返回当前map大小。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;isEmpty&lt;/strong&gt;：判断map是否为空。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;getEntry&lt;/strong&gt;：通过key找寻对应的entry节点。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;keySet和values&lt;/strong&gt;：通过迭代器返回key和value的集合，这里不进行讨论。&lt;/p&gt;

&lt;h2 id=&#34;hashmap若干问题:69821dbc4807e9884618c48763635519&#34;&gt;hashMap若干问题&lt;/h2&gt;

&lt;h4 id=&#34;容量为2的指数的奥妙:69821dbc4807e9884618c48763635519&#34;&gt;容量为2的指数的奥妙？&lt;/h4&gt;

&lt;p&gt;在文章开始，我们提到了hashmap数组容量必须为2的指数大小，而且构造函数参数如果不是2的指数还会调整到满足此规则的不小于传入参数的值，现在我们就来探究一下hashmap为什么要有这个规则。其实奥妙就在indexfor中,indexfor函数源码如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static int indexFor(int h, int length) {
return h &amp;amp; (length-1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键就是在于length-1把容量大小-1后二进制所有的位都变为1，这样会减少散列冲突。我们以长度16和长度15比较&lt;img src=&#34;http://oajsuo3nv.bkt.clouddn.com/2016-08-17-hashyu.jpg&#34; alt=&#34;&#34; /&gt;可以看到长度为15发生散列冲突，在散列值质量高的情况（hashmap通过hash函数保证），hashmap这种做法会让散列冲突尽可能减少。&lt;/p&gt;

&lt;h4 id=&#34;transient关键字:69821dbc4807e9884618c48763635519&#34;&gt;transient关键字？&lt;/h4&gt;

&lt;p&gt;我们可以看到hashmap中的table使用transient关键字修饰。transient关键字我们都熟悉，在序列化的时候可以不被序列化。那hashmap如何传值？答案当然是是通过writeObject，将hashmap中的值进行序列化。这里考虑到两个问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;空间考虑&lt;/strong&gt;：hashmap很多存储空间尚未使用，序列化没有意义，仅序列化存储元素数组&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;不同jvm考虑&lt;/strong&gt;：table中的内存分布是根据key的hashcode计算的，但是不同的jvm针对同一个可以产生的hashcode可能是不同的。如果使用默认序列化，反序列化之后元素位置是跟序列化之前相同的，可是这个jvm产生的hashcode变了，indexfor对于同一个key在不同的jvm对应不同的值，这样肯定不行的。这就是为什么要加transient关键字，为了就是忽略内存分布，通过readObject将hashmap重新生成。&lt;/p&gt;

&lt;h4 id=&#34;volatile关键字:69821dbc4807e9884618c48763635519&#34;&gt;volatile关键字？&lt;/h4&gt;

&lt;p&gt;在hashmap中，modCount、keySet、values都使用volatile关键字修饰。这里的原因其实很简单：我们知道volatile关键字一个特点就是内存可见性，某个变量修改之后其他线程会立即看到修改，上述三个变量都需要这样的特性，针对修改需要立即体现，所以用到了volatile关键字。&lt;/p&gt;

&lt;h4 id=&#34;非线程安全:69821dbc4807e9884618c48763635519&#34;&gt;非线程安全？&lt;/h4&gt;

&lt;p&gt;在多线程情况下，hashmap的put、get方法都是很脆弱的。这是一个比较大的话题，推荐大家看耗子叔的博客：&lt;a href=&#34;http://coolshell.cn/articles/9606.html&#34;&gt;疫苗：Java HashMap的死循环&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>